<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title> </title>
  <style>
    :root{
      --bg1:#070A12;
      --bg2:#0B1024;
      --glow: rgba(255,255,255,.12);
      --glow2: rgba(255,255,255,.07);
    }
    html,body{height:100%; margin:0;}
    body{
      overflow:hidden;
      background: radial-gradient(1200px 900px at 50% 40%, var(--bg2), var(--bg1));
      cursor: none;
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
    }

    /* No visible text, but keep accessibility hooks */
    .sr-only{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
    }

    #stage{
      position:relative;
      width:100%;
      height:100%;
      filter: saturate(1.1);
    }

    /* Soft grain overlay */
    #stage:before{
      content:"";
      position:absolute; inset:0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.20'/%3E%3C/svg%3E");
      opacity:.10;
      mix-blend-mode: overlay;
      pointer-events:none;
    }

    /* “Pointer” aura */
    #cursor{
      position:absolute;
      width:18px; height:18px;
      border-radius:50%;
      background: radial-gradient(circle, rgba(255,255,255,.18), rgba(255,255,255,0));
      transform: translate(-50%,-50%);
      pointer-events:none;
      filter: blur(.2px);
    }
    #cursor:after{
      content:"";
      position:absolute; inset:-18px;
      border-radius:50%;
      background: radial-gradient(circle, rgba(255,255,255,.06), rgba(255,255,255,0) 60%);
      filter: blur(2px);
    }

    /* Rings */
    .ring{
      position:absolute;
      left:50%; top:50%;
      width: 520px; height: 520px;
      transform: translate(-50%,-50%);
      border-radius:50%;
      border:1px solid rgba(255,255,255,.10);
      box-shadow: 0 0 40px rgba(255,255,255,.03);
      opacity:.75;
      transition: transform 600ms ease, opacity 600ms ease;
    }
    .ring:nth-child(2){ width: 360px; height:360px; opacity:.55;}
    .ring:nth-child(3){ width: 220px; height:220px; opacity:.45;}
    .ring:nth-child(4){ width: 120px; height:120px; opacity:.35;}

    /* Orb */
    #orb{
      position:absolute;
      width:72px; height:72px;
      border-radius:50%;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      background:
        radial-gradient(circle at 35% 30%, rgba(255,255,255,.35), rgba(255,255,255,0) 40%),
        radial-gradient(circle at 60% 70%, rgba(255,255,255,.12), rgba(255,255,255,0) 55%),
        rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.18);
      box-shadow:
        0 0 40px rgba(255,255,255,.06),
        inset 0 0 30px rgba(255,255,255,.08);
      transition: box-shadow 300ms ease, transform 250ms ease;
      will-change: transform, left, top;
    }
    #orb.grab{
      box-shadow: 0 0 60px rgba(255,255,255,.10), inset 0 0 40px rgba(255,255,255,.10);
      transform: translate(-50%,-50%) scale(1.05);
    }

    /* Particles */
    .p{
      position:absolute;
      width:6px; height:6px;
      border-radius:50%;
      background: rgba(255,255,255,.18);
      box-shadow: 0 0 18px rgba(255,255,255,.08);
      opacity:.0;
      pointer-events:none;
      will-change: transform, opacity;
    }

    /* Scene shift (unlocked state) */
    body.unlocked{
      background: radial-gradient(1200px 900px at 50% 40%, #0a1b22, #05070e);
    }
    body.unlocked .ring{
      border-color: rgba(255,255,255,.14);
      opacity:.88;
    }
  </style>
</head>
<body>
  <span class="sr-only" aria-hidden="false">
    Interactive visual experience. Use mouse or touch. No visible text by design.
  </span>

  <div id="stage" aria-label="Interactive shape field">
    <div class="ring"></div>
    <div class="ring"></div>
    <div class="ring"></div>
    <div class="ring"></div>

    <div id="orb" role="button" aria-label="Interactive orb"></div>
    <div id="cursor"></div>
  </div>

  <script>
    // ===== Utilities =====
    const stage = document.getElementById('stage');
    const orb = document.getElementById('orb');
    const cursor = document.getElementById('cursor');
    const rings = [...document.querySelectorAll('.ring')];

    let w = innerWidth, h = innerHeight;
    let mx = w/2, my = h/2;
    let ox = w/2, oy = h/2;
    let vx = 0, vy = 0;
    let dragging = false;
    let holdStart = null;
    let unlocked = false;

    addEventListener('resize', () => {
      w = innerWidth; h = innerHeight;
      mx = Math.min(Math.max(mx, 0), w);
      my = Math.min(Math.max(my, 0), h);
    });

    // ===== Sound (WebAudio; only after first interaction) =====
    let audioCtx = null;
    function ensureAudio(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') audioCtx.resume();
    }
    function ping(freq=220, dur=0.08, gain=0.05){
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine';
      o.frequency.setValueAtTime(freq, t);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
      o.connect(g).connect(audioCtx.destination);
      o.start(t);
      o.stop(t + dur + 0.02);
    }

    // ===== Particles =====
    const parts = [];
    for (let i=0;i<26;i++){
      const d = document.createElement('div');
      d.className = 'p';
      stage.appendChild(d);
      parts.push({el:d, a: Math.random()*Math.PI*2, r: 40+Math.random()*260, s: 0.5+Math.random()*1.8});
    }

    function setOrb(x,y){
      ox = x; oy = y;
      orb.style.left = x + 'px';
      orb.style.top = y + 'px';
    }
    setOrb(ox,oy);

    // ===== Pointer / touch handling =====
    function pointerMove(x,y){
      mx = x; my = y;
      cursor.style.left = x + 'px';
      cursor.style.top = y + 'px';
      if (dragging) setOrb(x,y);
    }

    stage.addEventListener('pointermove', (e) => {
      pointerMove(e.clientX, e.clientY);
    }, {passive:true});

    stage.addEventListener('pointerdown', (e) => {
      ensureAudio();
      const rect = orb.getBoundingClientRect();
      const cx = rect.left + rect.width/2;
      const cy = rect.top + rect.height/2;
      const dx = e.clientX - cx;
      const dy = e.clientY - cy;
      const dist = Math.hypot(dx,dy);

      if (dist < 60){
        dragging = true;
        orb.classList.add('grab');
        holdStart = performance.now();
        ping(220 + dist*1.2, 0.06, 0.06);
      } else {
        // “tap in space” creates a softer response
        ping(140 + (e.clientX/w)*260, 0.05, 0.03);
      }
      stage.setPointerCapture(e.pointerId);
    });

    stage.addEventListener('pointerup', (e) => {
      dragging = false;
      orb.classList.remove('grab');
      holdStart = null;
      ping(180, 0.05, 0.03);
      stage.releasePointerCapture(e.pointerId);
    });

    // Prevent context menu (long press)
    addEventListener('contextmenu', (e) => e.preventDefault());

    // ===== Animation loop =====
    function loop(t){
      // spring orb toward center when not dragging (gentle “gravity”)
      if (!dragging){
        const tx = w/2 + (mx - w/2) * 0.05;
        const ty = h/2 + (my - h/2) * 0.05;
        vx += (tx - ox) * 0.0025;
        vy += (ty - oy) * 0.0025;
        vx *= 0.92; vy *= 0.92;
        setOrb(ox + vx, oy + vy);
      }

      // ring reaction based on distance to cursor
      const dxm = mx - ox, dym = my - oy;
      const d = Math.hypot(dxm,dym);
      const pull = Math.max(0, 1 - d / 520);

      rings.forEach((r, i) => {
        const s = 1 + pull * (0.02 + i*0.01);
        const rot = (t*0.0006) * (i%2?1:-1);
        r.style.transform = `translate(-50%,-50%) scale(${s}) rotate(${rot}rad)`;
        r.style.opacity = (0.35 + pull*0.55) * (1 - i*0.12);
      });

      // particles orbit around orb (no text = “alive” field)
      parts.forEach((p, idx) => {
        p.a += 0.0025 * p.s * (unlocked ? 1.35 : 1.0);
        const rr = p.r + Math.sin(t*0.001 + idx)*10*(unlocked?1.6:1.0);
        const px = ox + Math.cos(p.a)*rr;
        const py = oy + Math.sin(p.a)*rr;
        p.el.style.transform = `translate(${px}px, ${py}px) translate(-50%,-50%)`;
        const op = 0.18 + pull*0.35;
        p.el.style.opacity = op;
      });

      // hold-to-unlock: keep pressed on orb ~1.2s
      if (!unlocked && holdStart && dragging){
        const held = t - holdStart;
        if (held > 1200){
          unlocked = true;
          document.body.classList.add('unlocked');
          // rising chord
          ping(220, 0.08, 0.05);
          setTimeout(()=>ping(330, 0.09, 0.05), 80);
          setTimeout(()=>ping(440, 0.10, 0.05), 170);
        }
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
